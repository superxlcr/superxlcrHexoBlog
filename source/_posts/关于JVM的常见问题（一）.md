---
title: 关于JVM的常见问题（一）
tags: [jvm,java,基础知识]
categories: [jvm]
date: 2016-03-28 10:00:11
description: 内存模型以及分区、堆里面的分区：Eden，survival from to，老年代，各自的特点、对象创建方法，对象的内存分配，对象的访问定位、GC的两种判定方法：引用计数与引用链、GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方
---
以下为一些常见的JVM问题的整合。

# 内存模型以及分区

JVM内存模型如下图所示：
![JVM内存模型示意图](1.jpg)

此处我们集中注意中间绿色的部分，该部分为JVM的运行时内存，该部分包含了：
线程私有的（灰色）：
1. 程序计数器：记录执行到第几条指令
2. 虚拟机方法栈：执行Java方法所用，每执行一个方法便加入一个栈帧，里面含有局部变量表、操作栈、动态链接和方法出口等
3. 本地方法栈：与虚拟机方法栈相似，用于执行native方法

线程共享的（蓝色）：
1. 堆：对象实例存放地，，分为年轻代和老年代。年轻代又细分为伊甸园区和两个相对的Survival区
2. 方法区：也叫永久代，存放了类的信息、常量、类静态变量等元素，含有一个运行时常量池

# 堆里面的分区：Eden，survival from to，老年代，各自的特点

## Eden区

Eden区位于Java堆的年轻代，是新对象分配内存的地方，由于堆是所有线程共享的，因此在堆上分配内存需要加锁。而Sun JDK为提升效率，会为每个新建的线程在Eden上分配一块独立的空间由该线程独享，这块空间称为TLAB（Thread Local Allocation Buffer）。在TLAB上分配内存不需要加锁，因此JVM在给线程中的对象分配内存时会尽量在TLAB上分配。如果对象过大或TLAB用完，则仍然在堆上进行分配。如果Eden区内存也用完了，则会进行一次Minor GC（young GC）。

## Survival from to

Survival区与Eden区相同都在Java堆的年轻代。Survival区有两块，一块称为from区，另一块为to区，这两个区是相对的，在发生一次Minor GC后，from区就会和to区互换。在发生Minor GC时，Eden区和Survival from区会把一些仍然存活的对象复制进Survival to区，并清除内存。Survival to区会把一些存活得足够旧的对象移至年老代。

## 年老代

年老代里存放的都是存活时间较久的，大小较大的对象，因此年老代使用标记整理算法。当年老代容量满的时候，会触发一次Major GC（full GC），回收年老代和年轻代中不再被使用的对象资源。

# 对象创建方法，对象的内存分配，对象的访问定位

## 对象的创建

Java对象的创建大致上有以下几个步骤：
1. **类加载检查**：检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类的加载过程
为对象分配内存：对象所需内存的大小在类加载完成后便完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。由于堆被线程共享，因此此过程需要进行同步处理（分配在TLAB上不需要同步）
2. **内存空间初始化**：虚拟机将分配到的内存空间都初始化为零值（不包括对象头），内存空间初始化保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
3. **对象设置**：JVM对对象头进行必要的设置，保存一些对象的信息（指明是哪个类的实例，哈希码，GC年龄等）
4. **init**：执行完上面的4个步骤后，对JVM来说对象已经创建完毕了，但对于Java程序来说，我们还需要对对象进行一些必要的初始化。

## 对象的内存分配

Java对象的内存分配有两种情况，由Java堆是否规整来决定（Java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定）：
1. 指针碰撞(Bump the pointer)：如果Java堆中的内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存也就是把指针向空闲空间那边移动一段与内存大小相等的距离
2. 空闲列表(Free List)：如果Java堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，就没有办法简单的进行指针碰撞了。虚拟机必须维护一张列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

## 对象的访问定位

对象的访问形式取决于虚拟机的实现，目前主流的访问方式有使用句柄和直接指针两种：
**使用句柄：**
如果使用句柄访问，Java堆中将会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息：
![句柄访问示意图](2.jpg)

优势：引用中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而引用本身不需要修改。

**直接指针：**
如果使用直接指针访问对象，那么对象的实例数据中就包含一个指向对象类型数据的指针，引用中存的直接就是对象的地址：
![直接指针示意图](3.jpg)

优势：速度更快，节省了一次指针定位的时间开销，积少成多的效应非常可观。

# GC的两种判定方法：引用计数与引用链

基于引用计数与基于引用链这两大类别的自动内存管理方式最大的不同之处在于：前者只需要局部信息，而后者需要全局信息

## 引用计数

引用计数顾名思义，就是记录下一个对象被引用指向的次数。引用计数方式最基本的形态就是让每个被管理的对象与一个引用计数器关联在一起，该计数器记录着该对象当前被引用的次数，每当创建一个新的引用指向该对象时其计数器就加1，每当指向该对象的引用失效时计数器就减1。当该计数器的值降到0就认为对象死亡。每个计数器只记录了其对应对象的局部信息——被引用的次数，而没有（也不需要）一份全局的对象图的生死信息。由于只维护局部信息，所以不需要扫描全局对象图就可以识别并释放死对象；但也因为缺乏全局对象图信息，所以无法处理循环引用的状况。

## 引用链

引用链需要内存的全局信息，当使用引用链进行GC时，从对象图的“根”（GC Root，必然是活的引用，包括栈中的引用，类静态属性的引用，常量的引用，JNI的引用等）出发扫描出去，基于引用的可到达性算法来判断对象的生死。这使得对象的生死状态能批量的被识别出来，然后批量释放死对象。引用链不需要显式维护对象的引用计数，只在GC使用可达性算法遍历全局信息的时候判断对象是否被引用，是否存活。

# GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方

## 标记清除

标记清除算法分两步执行：
1. 暂停用户线程，通过GC Root使用可达性算法标记存活对象
2. 清除未被标记的垃圾对象

标记清除算法缺点如下：
1. 效率较低，需要暂停用户线程
2. 清除垃圾对象后内存空间不连续，存在较多内存碎片

标记算法如今使用的较少了

## 复制算法

复制算法也分两步执行，在复制算法中一般会有至少两片的内存空间（一片是活动空间，里面含有各种对象，另一片是空闲空间，里面是空的）：
1. 暂停用户线程，标记活动空间的存活对象
2. 把活动空间的存活对象复制到空闲空间去，清除活动空间

复制算法相比标记清除算法，优势在于其垃圾回收后的内存是连续的。
但是复制算法的缺点也很明显：
1. 需要浪费一定的内存作为空闲空间
2. 如果对象的存活率很高，则需要复制大量存活对象，导致效率低下

复制算法一般用于年轻代的Minor GC，主要是因为年轻代的大部分对象存活率都较低

## 标记整理

标记整理算法是标记清除算法的改进，分为标记、整理两步：
1. 暂停用户线程，标记所有存活对象
2. 移动所有存活对象，按内存地址次序一次排列，回收末端对象以后的内存空间

标记整理算法与标记清除算法相比，整理出的内存是连续的；而与复制算法相比，不需要多片内存空间。
然而标记整理算法的第二步整理过程较为麻烦，需要整理存活对象的引用地址，理论上来说效率要低于复制算法。
因此标记整理算法一般引用于老年代的Major GC